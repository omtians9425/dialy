# 12/5
## Koin 3.3 移行
https://github.com/InsertKoinIO/koin/blob/main/CHANGELOG.md#33

Deprecated APIs があり、以下の移行が必要
- `stateViewModel()` -> `viewModel()`
- `sharedViewModel()` -> `activityViewModel()`
- `sharedStateViewModel()` -> `activityViewModel()`

# 12/7
## ActivityScenario と ComposeTestRule の組み合わせによる所望画面状態の待機
以下のような状況があった
- Activity 内に Fragment が表示される
- その Fragment の中身を Compose に移行した
- Android View の時に書かれていた VRT 用のテストコードが動かなくなった
  - [所望画面状態の待機](https://blog.studysapuri.jp/entry/2022-03-22/android-vrt-tips-2)には View id が必要だが、Compose 移行により指定できなくなってしまった

結論として、別途 ComposeTestRule を用いて assert することで待機させることができた。
```kt
@Test
fun takeHogeScreen() {
    launchHogeFragment().use { // ActivityScenario から Fragment を表示
        // Wait for expected state
        composeTestRule.onNode(hasTestTag("someInputBox")).assert(hasText("名前を入力して下さい"))

        it.takeScreenshot(
            testName = testName,
            screenName = HogeFragment::class.simpleName
        )
    }
}
```

# 12/8
## Repository が Flow を返し、ViewModel が StateFlow の場合の unit test
Repository が複数の値を流す（例えば loading, content の順）場合、`StateFlow.value` を単に読むだけだと初期値が取れてしまう。
明示的に全ての値を collect して取得する必要がある。

- https://speakerdeck.com/tkmnzm/update-your-automated-tests-to-match-androids-modern-technology-choices?slide=96
- https://developer.android.com/kotlin/flow/test#continuous-collection
- https://at-sushi.work/blog/20/
- https://qiita.com/myoshita/items/ddf32d1629abeaa8442c#runtest

## Kotlin Context receivers
https://github.com/Kotlin/KEEP/blob/master/proposals/context-receivers.md#use-cases

拡張関数に新たなスコープを与えたい時とかに使えそうに思う。ただ context の field にアクセスできてしまうので、例えば context の中でだけ呼べる関数が作れればいいというだけの理由で context receiver を使うのはやや too much かもしれない。

あとは context に制限するのはいいが unit test 等でこの関数を mock したいと思った時、context のインスタンスが無いと mock できないためやや不便になることがある。

## Kotlin の ArrayList
以下を decompile すると
```kotlin
class Hoge {

    fun main() {
        val arrayList = arrayListOf(1, 2, 3)
        val list = listOf(1, 2, 3)
        val mutableList = mutableListOf(1, 2, 3)
        val array = arrayOf(1, 2, 3)
    }
}
```
こうなる
```java
public final class Hoge {
   public final void main() {
      ArrayList arrayList = CollectionsKt.arrayListOf(new Integer[]{1, 2, 3});
      List list = CollectionsKt.listOf(new Integer[]{1, 2, 3});
      List mutableList = CollectionsKt.mutableListOf(new Integer[]{1, 2, 3});
      Integer[] var10000 = new Integer[]{1, 2, 3};
   }
}
```

`CollectionsKt.arrayListOf` をクラスファイルで見るとこんな定義になっている
```
@kotlin.SinceKotlin @kotlin.internal.InlineOnly public inline fun <T> arrayListOf(): kotlin.collections.ArrayList<T> /* = java.util.ArrayList<T> */ { /* compiled code */ }
```

ちなみに Kotlin 上で java.util.ArrayList に対して kotlin.collections.ArrayList は代入可能
```kt
class Hoge {

    fun main() {
        val a = java.util.ArrayList<Int>(3)
        a.add(2)
        val b: ArrayList<Int> = a
        val c: java.util.ArrayList<Int> = arrayListOf(1)
    }
}
```

decompile すると以下
```java
public final class Hoge {
   public final void main() {
      ArrayList a = new ArrayList(3);
      a.add(2);
      ArrayList c = CollectionsKt.arrayListOf(new Integer[]{1});
   }
}
```
arrayListOf といった syntax sugar を提供するために kotlin.collections.ArrayList が存在している...?

CollectionsKt.arrayListOf が new ArrayList() と ArrayList.add の繰り返しに decompile されないのは不思議。
Integer[] を ArrayList に変換する native 実装があると思われる。

一方 Array について、
```kt
        val array = Array(3) { 1 }
```
は
```java
      byte var2 = 3;
      Integer[] var3 = new Integer[var2];

      for(int var4 = 0; var4 < var2; ++var4) {
         int var6 = false;
         Integer var9 = 1;
         var3[var4] = var9;
      }
```
になる